---
layout: post
title: 주요 디자인 패턴 용약
image: 4.jpg
date: 2021-03-09 18:40:20 +0200
tags: NHN 기술교육 디자인패턴
categories: 개인학습
---
<h3>1. Stratgy Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110408520-083e1400-80c9-11eb-991f-ebfc61f170e4.png)
- 특정 컨텍스트에서 알고리즘(전략)을 별도로 분리하는 설계 방법.
- 컨텍스트 코드의 변경 없이 새로운 전략을 추가 할 수 있다.(OCP를 따르는 구조)
<br><br>
<h3>2. Template Method Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110408987-de392180-80c9-11eb-8667-c38197a28491.png)
- 상위 클래스에서 처리의 흐름을 제어하며, 하위클래스에서 처리의 내용을 구체화한다.
- 여러 클래스에서 공통되는 사항은 상위 추상 클래스에서 구현하고, 각각의 상세부분은 하위 클래스에서 구현한다.
- 코드의 중복을 줄이고, Refactoring에 유리한 패턴으로 상속을 통한 확장 개발 방법으로써 많이 사용되는 패턴 중 하나.
<br><br>
<b>[고려사항]</b>
1. 멤버 함수들의 접근 범위 지정에 대한 명확화 필요. 
2. 가상함수, 일반함수 선언에 대한 결정이 필요. (반드시 구현이 필요한 메서드는 가상함수, 필요한 경우에만 구현하는 경우 일반)
3. Virtual의 수를 줄이는 것이 필요. (virtual table 확장에 따른 성능 문제 발생)
<br><br>
<h3>3. State Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110410665-9a93e700-80cc-11eb-8c53-30bce3a68e69.png)
- 객체의 상태에 따라 각각의 행위를 변경할 수 있게 캡슐화한다.
- 동적으로 행동을 교체한다는 점에서 전략패턴과 구조는 거의 동일하나 쓰임의 용도가 다름.
- 컨텍스트의 상태 변경을 상태 객체에게 위임할수도 있고 컨텍스트가 직접 하기도 함. (장단점이 있어 상황에 맞게)
<br><br>
<h3>4. Decorator Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110421497-f9635b80-80e0-11eb-9537-4156d8aa111a.png)
- 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 상속 대신 위임의 방식으로 기능을 확장해 나간다.
- 동적으로 객체의 추가적인 기능들을 가진 객체를 덧붙여 꾸밀 수 있다. 
<br><br>
<b>[고려사항]</b>
1. 데코레이터 대상이 되는 타입의 기능 개수를 고려해야함 (정의된 메서드가 증가함에 따라 데코레이터의 구현도 복잡해짐)
<br><br>
<h3>5. Proxy Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110423218-003f9d80-80e4-11eb-9f2d-614ce5e3b0cd.png)
- 대리자로써 일을 맡기면 그 일을 처리하고 완료되면 그 결과를 알려주는 패턴
- 상황에 따라 가상 프록시, 보호 프록시, 원격 프록시 등으로 구현한다. (구현방법은 차이가 있음)
<br><br>
<h3>6. Adapter Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110428820-48af8900-80ed-11eb-8757-b9af7bda8172.png)
- 서로 다르게 구현된 인터페이스를 사용하고자 하는 다른 인터페이스로 변환한다.
- 어댑터 패턴은 상속(Adaptee클래스 상속)으로 구현하는 클래스 어댑터 패턴과, 구성으로 구현하는 객체 어댑터 패턴으로 나뉜다.
- 클래스 어댑터 패턴은 클라이언트가 사용하는 것이 인터페이스가 아닌 추상 클래스라면 구현이 불가능하다. (자바는 단일 상속만 지원)
<br><br>
<h3>7. Observer Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110429858-dcce2000-80ee-11eb-8a31-c2039ef4dfe2.png)
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 모두 연락이 가고 자동으로 내용이 갱신되는 패턴.
- 1:N의 의존성으로 정의되며, Broadcast 방식의 패턴.
- 위 그림에서는 옵저버객체가 주제 객체를 의존 하지만 필요없는 경우 의존하지 않아도 된다. (파라미터로 상태 전달 가능한 경우)
<br><br>
<b>[고려사항]</b>
1. 주제객체에서 상태변경을 통지할 것인지, 주제객체를 사용하는 클라이언트에서 상태변경을 통지할 것인지 고려 필요.
   (클라이언트에서 통지할 경우 상태를 변경하는 모든 코드에서 호출해야하므로 개발자의 실수 유발 가능)
2. 옵저버 인터페이스를 적절하게 분리해야함 (여러 옵저버를 사용할 경우 하나의 인터페이스가 거대해 질 수 있음)
3. 통지 시점에 주제 객체 상태에 결함이 없도록 해야함 (템플릿 메서드 패턴을 사용하여 전달 프로세스를 정해놓을 수 있음)
<br><br>
<h3>8. Mediator Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110432748-dcd01f00-80f2-11eb-9786-9dc051ce4540.png)
- 모든 클래스간의 복잡한 로직(상호작용)을 캡슐화하여 하나의 클래스에 위임하여 처리하는 패턴
- M:N의 관계에서 M:1의 관게로 복잡도를 떨어뜨려 유지보수 및 재사용 확장성에 유리하다
- 협업 객체 간의 동일한 메시지 흐름이 서로 다른 기능에서 반복 사용될 경우 미디에이터 추상 클래스를 사용하여 재사용을 높힘.
<br><br>
<h3>9. Facade Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110450005-1fe7bd80-8106-11eb-9bb7-43ed5f8e9f76.png)
- 서브 시스템을 감춰주는 상위 수준의 인터페이스를 제공하여 코드중복(여러 클라이언트일 경우)과 직접적인 의존을 해결할 수 있도록 함.
- 클라이언트의 변경 없이 서브 시스템 자체를 변경할 수 있음.
<br><br>
<h3>10. Abstract Factory Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110450814-e5325500-8106-11eb-87de-6bcaf00571c4.png)
- 객체를 대신 생성해주는 팩토리 관점은 동일하다
- 다양한 구성 요소 별로 '객체의 집합'을 생성해야 할 때 유리하다. 즉, 서로 다른 객체들을 하나의 팩토리에서 생성/관리한다.
- 클라이언트에게 영향을 주지 않으면서 사용할 제품군을 교체할 수 있다. (구상팩토리를 선택하면 특정 구상제품만 사용됨)
- 만일 팩토리가 생성하는 객체가 늘 동일한 상태면 프로토타입 방식(특정 객체들을 미리 생성해서 모아둔 객체)으로 팩토리를 구현.
<br><br>
<h3>11. Composite Pattern </h3>
![image](https://user-images.githubusercontent.com/38030969/110452515-9980ab00-8108-11eb-97f0-16d95ab92c30.png)
- 부분과 전체를 구분없이 하나의 인터페이스로 추상화한 패턴.
- 컴포지트(전체)에서 기능 실행을 컴포넌트(부분)들에게 위임한 것.
<b>[고려사항]</b>
1. 컴포넌트와 컴포지트 객체가 외부에서는 구분되지 않기 때문에 컴포넌트가 컴포지트만의 메소드를 사용할 경우 예외처리 필요.
<br><br>
 컴포지트 객체가 외부에서는 구분되지 않기 때문에 컴포넌트가 컴포지트만의 메소드를 사용할 경우 예외처리 필요.
<br><br>
